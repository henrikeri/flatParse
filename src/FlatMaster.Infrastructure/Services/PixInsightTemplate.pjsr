// === Flat Master Executor (PixInsight 1.8.9+) ===
// Generated by FlatMaster C# Application

// Sentinel path for completion signaling (set independently of CFG for error catch)
var __SENTINEL = "%SENTINEL_PATH%";
function touch(p, s){ try{ if(!p) return; var f=new File; f.createForWriting(p); if(s) f.outTextLn(s); f.close(); }catch(e){} }
function pulse(tag){ try{ touch(__SENTINEL + ".progress", tag); }catch(_){ } }

// Configuration object injected by C# code generation.
var CFG = %CONFIG_JS_OBJECT_LITERAL%;

// Guard top-level references so parse/evaluation cannot fail before try/catch.
var __ImageIntegrationClass = (typeof ImageIntegration !== "undefined") ? ImageIntegration : {};

// -------- Helper Functions --------
function log(s){ try{ if (typeof Console !== "undefined" && Console.writeln) Console.writeln(s); }catch(e){} }
function warn(s){ try{ if (typeof Console !== "undefined" && Console.warningln) Console.warningln(s); }catch(e){} }
function error(s){ try{ if (typeof Console !== "undefined" && Console.criticalln) Console.criticalln(s); }catch(e){} }
function joinPath(a,b){ if(!a)return b; var slash=(a.indexOf("\\")>=0)?"\\":"/"; if(a.endsWith("/")||a.endsWith("\\"))return a+b; return a+slash+b; }
function parentDir(p){ if (!p) return ""; var i = Math.max(p.lastIndexOf("/"), p.lastIndexOf("\\")); return i>0 ? p.substring(0,i) : ""; }
function ensureDir(p){ if (p && !File.directoryExists(p)) File.createDirectory(p, true); }
function kexp(x){ return (Math.round(x*1000)/1000).toString(); }
function baseName(p){ return p.replace(/^.*[\\/]/,''); }

// Enum resolution with fallbacks
function enumVal(klass, names, defVal){
  for (var i=0;i<names.length;i++){
    var n = names[i];
    try{ if (typeof klass[n] === "number") return klass[n]; }catch(e){}
    try{ if (klass.prototype && typeof klass.prototype[n] === "number") return klass.prototype[n]; }catch(e){}
  }
  return defVal;
}

var II_ENUM = {
  Comb_Average:  enumVal(__ImageIntegrationClass, ["Average"], 0),
  Weight_Dont:   enumVal(__ImageIntegrationClass, ["DontCare","Weight_DontCare"], 0),
  Norm_None:     enumVal(__ImageIntegrationClass, ["NoNormalization","NoScale","NoScaling"], 0),
  Norm_Mult:     enumVal(__ImageIntegrationClass, ["Multiplicative"], enumVal(__ImageIntegrationClass, ["NoNormalization"], 0)),
  Rej_None:      enumVal(__ImageIntegrationClass, ["NoRejection"], 0),
  Rej_Winsor:    enumVal(__ImageIntegrationClass, ["WinsorizedSigmaClipping","WinsorizedSigmaClip"], enumVal(__ImageIntegrationClass, ["NoRejection"], 0)),
  Rej_PC:        enumVal(__ImageIntegrationClass, ["PercentileClip","Percentile"], enumVal(__ImageIntegrationClass, ["NoRejection"], 0)),
  Rej_LinFit:    enumVal(__ImageIntegrationClass, ["LinearFit"], enumVal(__ImageIntegrationClass, ["NoRejection"], 0)),
  RejNorm_None:  enumVal(__ImageIntegrationClass, ["NoRejectionNormalization","NoNormalization"], 0),
  RejNorm_Eq:    enumVal(__ImageIntegrationClass, ["EqualizeFluxes","RejectionNormalization_EqualizeFluxes"], enumVal(__ImageIntegrationClass, ["NoRejectionNormalization"], 0))
};

function assignIIImagesRowsPaths(II, paths){
  var rows = [];
  for (var i=0;i<paths.length;i++) rows.push([ true, String(paths[i]), "", "" ]);
  II.images = rows;
}

function assignICTargets(IC, paths){
  var rows = [];
  for (var i=0;i<paths.length;i++) rows.push([true, String(paths[i])]);
  IC.targetFrames = rows;
}

function saveXISF(win, outPath, hints){
  ensureDir(parentDir(outPath));
  var tried = [];
  function tryCall(label, fn){
    try{
      fn();
      log("  [saveAs " + label + "] " + outPath);
      return true;
    } catch(e){
      tried.push(label + ": " + e);
      return false;
    }
  }
  if (tryCall("path,format,hints", function(){ win.saveAs(outPath, "xisf", hints); })) return;
  if (tryCall("path,format,hints,overwrite", function(){ win.saveAs(outPath, "xisf", hints, false); })) return;
  if (tryCall("path,format", function(){ win.saveAs(outPath, "xisf"); })) return;
  if (tryCall("path,overwrite,format,hints", function(){ win.saveAs(outPath, false, "xisf", hints); })) return;
  if (tryCall("path,overwrite", function(){ win.saveAs(outPath, false); })) return;
  if (tryCall("path-only", function(){ win.saveAs(outPath); })) return;
  throw new Error("saveAs failed for " + outPath + " ; tried => " + tried.join(" | "));
}

function safeNum(x){ return (x===undefined||x===null||isNaN(x)) ? NaN : Number(x); }

function metaScore(c,want,match){
  var s=0;
  var cg=safeNum(c.gain), wg=safeNum(want.gain);
  var co=safeNum(c.offset), wo=safeNum(want.offset);
  var ct=safeNum(c.temp), wt=safeNum(want.temp);
  if(match.enforceBinning && want.binning && c.binning && c.binning===want.binning) s+=3;
  if(match.preferSameGainOffset){
    if(!isNaN(cg) && !isNaN(wg) && Math.abs(cg-wg) < 0.01) s+=2;
    if(!isNaN(co) && !isNaN(wo) && Math.abs(co-wo) < 0.5 ) s+=2;
  }
  if(match.preferClosestTemp && !isNaN(ct) && !isNaN(wt)){
    var dt=Math.abs(ct - wt);
    if (dt <= match.maxTempDeltaC) s += (1.5 - dt*0.2);
  }
  return s;
}

function typePriority(t){
  if (t === "MASTERDARKFLAT") return 0;
  if (t === "DARKFLAT") return 1;
  if (t === "MASTERDARK") return 2;
  if (t === "DARK") return 3;
  if (t === "MASTERBIAS") return 4;
  if (t === "BIAS") return 5;
  return 99;
}

function typeLabel(t){
  if (t === "MASTERDARKFLAT") return "MasterDarkFlat";
  if (t === "DARKFLAT") return "DarkFlat";
  if (t === "MASTERDARK") return "MasterDark";
  if (t === "DARK") return "Dark";
  if (t === "MASTERBIAS") return "MasterBias";
  if (t === "BIAS") return "Bias";
  return String(t || "Unknown");
}

function isDarkCalibrationType(t){
  return t === "MASTERDARKFLAT" || t === "DARKFLAT" || t === "MASTERDARK" || t === "DARK";
}

function chooseBestByScore(candidates, want, match){
  var best = null;
  var bestScore = -1e99;
  var bestPriority = 999;

  for (var i=0; i<candidates.length; i++){
    var c = candidates[i];
    var score = metaScore(c, want, match);
    var pri = typePriority(c.type);
    if (best === null || score > bestScore || (score === bestScore && pri < bestPriority)){
      best = c;
      bestScore = score;
      bestPriority = pri;
    }
  }

  return best;
}

function chooseNearest(candidates, exp, want, match){
  var best = null;
  var bestDelta = 1e99;
  var bestScore = -1e99;
  var bestPriority = 999;

  for (var i=0; i<candidates.length; i++){
    var c = candidates[i];
    var cexp = safeNum(c.exposure);
    if (isNaN(cexp)) continue;

    var delta = Math.abs(cexp - exp);
    var score = metaScore(c, want, match);
    var pri = typePriority(c.type);

    if (best === null || delta < bestDelta || (delta === bestDelta && (score > bestScore || (score === bestScore && pri < bestPriority)))){
      best = c;
      bestDelta = delta;
      bestScore = score;
      bestPriority = pri;
    }
  }

  if (best === null) return null;
  return { candidate: best, delta: bestDelta };
}

function integrateToMaster(paths,outPath,forDark,hints,rej){
  if(!paths.length) throw new Error("No frames for "+outPath);
  if(paths.length < 3) throw new Error("ImageIntegration needs >=3 inputs; got "+paths.length);

  var II=new ImageIntegration;
  assignIIImagesRowsPaths(II, paths);

  II.combination = II_ENUM.Comb_Average;
  II.weightMode  = II_ENUM.Weight_Dont;
  II.evaluateNoise = false;
  II.generate64BitResult = true;
  II.generateRejectionMaps = false;
  II.generateSlopeMaps = false;
  II.generateIntegratedImage = true;

  if(forDark){
    II.normalization = II_ENUM.Norm_None;
    II.rejection = II_ENUM.Rej_Winsor;
    II.rejectionNormalization = II_ENUM.RejNorm_None;
  } else {
    II.normalization = II_ENUM.Norm_Mult;
    II.rejectionNormalization = II_ENUM.RejNorm_Eq;

    var n = paths.length;
    if (n < 6) {
      II.rejection = II_ENUM.Rej_PC;
      II.pcClipLow = 0.20;
      II.pcClipHigh = 0.10;
    } else if (n <= 15) {
      II.rejection = II_ENUM.Rej_Winsor;
      II.sigmaLow = 4.0;
      II.sigmaHigh = 3.0;
      II.winsorizationCutoff = 5.0;
      II.clipLow = true;
      II.clipHigh = true;
    } else {
      II.rejection = II_ENUM.Rej_LinFit;
      II.linearFitLow = 5.0;
      II.linearFitHigh = 4.0;
      II.clipLow = true;
      II.clipHigh = true;
    }
    II.largeScaleClipHigh = false;
  }

  if (II.rejection === II_ENUM.Rej_Winsor && rej) {
    if (typeof rej.lowSigma === "number") II.sigmaLow = rej.lowSigma;
    if (typeof rej.highSigma === "number") II.sigmaHigh = rej.highSigma;
  }

  // Keep integration windows hidden in automation mode to avoid UI stalls.
  II.showImages = false;
  var okII = II.executeGlobal();
  II.showImages = true;
  if(!okII) throw new Error("ImageIntegration failed: "+outPath);

  // Give PI time to publish integration window identifiers in automation mode.
  for (var settle=0; settle<20; settle++)
    try{ if (typeof processEvents === "function") processEvents(); }catch(_){}

  var id="";
  var win=null;
  // In automation mode the integration image can appear slightly later.
  for (var w=0; w<200; w++){
    try{
      id = II.integrationImageId;
      if (id && typeof id === "string" && id.length)
        win = ImageWindow.windowById(id);
    } catch(_){}
    if (win) break;
    try{ if (typeof processEvents === "function") processEvents(); }catch(_){}
  }
  if(!win) throw new Error("Integration window not found");

  try {
    var imgType = (!forDark) ? "Master Flat" : "Master Dark";
    var kws = win.keywords || [];
    kws.push(new FITSKeyword("IMAGETYP", imgType, "Type of image"));
    win.keywords = kws;
  } catch (e) { warn("[metadata] IMAGETYP not set: " + e); }

  saveXISF(win, outPath, hints);
  win.forceClose();

  var extraIds = [ II.lowRejectionMapImageId, II.highRejectionMapImageId, II.slopeMapImageId ];
  for (var ii=0;ii<extraIds.length;ii++){
    var eid = extraIds[ii];
    if (eid && typeof eid === "string" && eid.length){
      var ew = ImageWindow.windowById(eid);
      if (ew) try{ ew.forceClose(); }catch(_){ }
    }
  }

  // Let PI complete deferred window/state updates before continuing script flow.
  for (var pe=0; pe<20; pe++)
    try{ if (typeof processEvents === "function") processEvents(); }catch(_){}
}

function calibrateFlats(paths,outDir,masterDarkPath,optimize,hints){
  ensureDir(outDir);
  var IC=new ImageCalibration;
  assignICTargets(IC, paths);

  IC.masterBiasEnabled = false;
  IC.masterFlatEnabled = false;
  if (masterDarkPath){
    IC.masterDarkEnabled = true;
    IC.masterDarkPath = masterDarkPath;
    IC.optimizeDarks = !!optimize;
  } else {
    IC.masterDarkEnabled = false;
    IC.masterDarkPath = "";
    IC.optimizeDarks = false;
  }

  IC.outputDirectory=outDir;
  IC.outputExtension=".xisf";
  IC.outputPrefix="";
  IC.outputPostfix="_c";
  IC.outputHints=hints;
  try { IC.outputSampleFormat = ImageCalibration.prototype.f32; } catch(_){}
  try { IC.overwriteExistingFiles = true; } catch(_){}
  try { IC.onError = ImageCalibration.prototype.Continue; } catch(_){}

  if(!IC.executeGlobal()) throw new Error("ImageCalibration failed.");

  var out = [];
  try{
    var od = IC.outputData || [];
    for (var i=0; i<od.length; i++){
      var row = od[i];
      if (row && row.length && row[0]) out.push(String(row[0]));
    }
  } catch(_){}

  // Give PI a short chance to finalize output metadata/state for this batch.
  for (var pe=0; pe<20; pe++)
    try{ if (typeof processEvents === "function") processEvents(); }catch(_){}

  return out;
}

function pickDarkFor(exp, want, cacheDir, cats, rej, hintsCal, match){
  var exact = [];
  for (var i=0;i<cats.length;i++){
    var c = cats[i];
    if (!isDarkCalibrationType(c.type)) continue;
    var cexp = safeNum(c.exposure);
    if (isNaN(cexp)) continue;
    if (Math.abs(cexp - exp) < 0.001) exact.push(c);
  }

  // 1) Exact dark match (time + metadata score, including temperature).
  if (exact.length){
    var bestExact = chooseBestByScore(exact, want, match);
    return { path: bestExact.path, optimize: false, kind: typeLabel(bestExact.type) + "(exact)" };
  }

  if (CFG.allowNearestExposureWithOptimize){
    var near2 = [];
    var near10 = [];

    for (var j=0;j<cats.length;j++){
      var d = cats[j];
      if (!isDarkCalibrationType(d.type)) continue;
      var dexp = safeNum(d.exposure);
      if (isNaN(dexp)) continue;
      var delta = Math.abs(dexp - exp);

      if (delta >= 0.001 && delta <= 2.0) near2.push(d);
      else if (delta > 2.0 && delta <= 10.0) near10.push(d);
    }

    // 2) Nearest dark within <2s.
    var best2 = chooseNearest(near2, exp, want, match);
    if (best2){
      return {
        path: best2.candidate.path,
        optimize: false,
        kind: typeLabel(best2.candidate.type) + "(nearest<=2s," + kexp(best2.candidate.exposure) + "s)"
      };
    }

    // 3) Nearest dark within <10s (with optimization).
    var best10 = chooseNearest(near10, exp, want, match);
    if (best10){
      return {
        path: best10.candidate.path,
        optimize: true,
        kind: typeLabel(best10.candidate.type) + "(nearest<=10s+optimize," + kexp(best10.candidate.exposure) + "s)"
      };
    }
  }

  // 4) Bias fallback.
  var masterBias = [];
  var bias = [];
  for (var k=0;k<cats.length;k++){
    var b = cats[k];
    if (b.type === "MASTERBIAS") masterBias.push(b);
    else if (b.type === "BIAS") bias.push(b);
  }

  if (masterBias.length){
    var bestMasterBias = chooseBestByScore(masterBias, want, match);
    return { path: bestMasterBias.path, optimize: false, kind: "MasterBias" };
  }

  if (bias.length >= 3){
    var outBias = joinPath(cacheDir, "MasterBias.xisf");
    integrateToMaster(bias.map(function(x){ return x.path; }), outBias, true, hintsCal, rej);
    return { path: outBias, optimize: false, kind: "Bias(built)" };
  }

  if (bias.length){
    var bestBias = chooseBestByScore(bias, want, match);
    return { path: bestBias.path, optimize: false, kind: "Bias(single)" };
  }

  // 5) No dark/bias found.
  return null;
}

function guessFilterFrom(files, dir){
  var rx = /(?:^|[_\-])(?:FILTER|Filter)[_\-]?([A-Za-z0-9]+)/;
  for (var i=0;i<files.length;i++){
    var m = baseName(files[i]).match(rx);
    if (m && m[1]) return String(m[1]).toUpperCase();
  }
  var parts = dir.replace(/\\/g,"/").split("/");
  var last = parts.length ? parts[parts.length-1] : "";
  if (last && !/^\d{4}-\d{2}-\d{2}$/.test(last)) return last.toUpperCase();
  return "UNKNOWN";
}

function guessDateFromPath(dir, files){
  var rx = /\b(20\d{2}-\d{2}-\d{2})\b/;
  var m = dir.match(rx);
  if (m) return m[1];
  for (var i=0;i<files.length;i++){
    var mm = files[i].match(rx);
    if (mm) return mm[1];
  }
  return "UNKNOWNDATE";
}

// -------- Main Processing --------
function run(){
  try{ if (typeof Console !== "undefined" && Console.show) Console.show(); }catch(_){}
  if (typeof ImageIntegration === "undefined" || typeof ImageCalibration === "undefined" || typeof ImageWindow === "undefined")
    throw new Error("PixInsight process classes unavailable in this execution mode.");
  pulse("RUN_START");

  var plan = CFG.plan || [];
  var cats = CFG.darkCatalog || [];
  var rej = CFG.rejection || {lowSigma:5.0, highSigma:5.0};
  var hintsCal = CFG.xisfHintsCal||"";
  var hintsMaster= CFG.xisfHintsMaster||"";
  var match = CFG.match || {};

  for (var j=0;j<plan.length;j++){
    var job=plan[j], dir=job.dirPath;
    log("\n=== FLAT dir: "+dir+" ===");

    var rel = job.relDir || "";
    if (rel === ".") rel = "";
    var outRoot = job.outRoot || dir;
    var outBase = rel ? joinPath(outRoot, rel) : outRoot;
    ensureDir(outBase);

    for (var g=0; g<job.groups.length; g++){
      var grp=job.groups[g], exp=grp.exposure, files=grp.files, want=grp.want || {};
      if (want.binning === undefined) want.binning = null;
      if (want.gain === undefined) want.gain = null;
      if (want.offset === undefined) want.offset = null;
      if (want.temp === undefined) want.temp = null;

      log("  Exposure "+kexp(exp)+" s : "+files.length+" flats");

      var dateStr = guessDateFromPath(dir, files);
      var filt = guessFilterFrom(files, dir);
      var masterName = "MasterFlat_" + dateStr + "_" + filt + "_" + kexp(exp) + "s.xisf";
      var masterOut = joinPath(outBase, masterName);

      if (File.exists(masterOut)){
        log("  SKIP (master already exists): " + masterOut);
        continue;
      }

      var cacheDir = joinPath(dir, CFG.cacheDirName||"_DarkMasters");
      var sel = pickDarkFor(exp, want, cacheDir, cats, rej, hintsCal, match);

      if(!sel || !sel.path){
        warn("  No suitable dark/bias @ " + kexp(exp) + " s in " + dir + " - integrating flats without subtraction.");
        pulse("NO_DARK_BEFORE_INTEGRATE");
        integrateToMaster(files, masterOut, false, hintsMaster, rej);
        pulse("NO_DARK_AFTER_INTEGRATE");
        for (var pe1=0; pe1<10; pe1++)
          try{ if (typeof processEvents === "function") processEvents(); }catch(_){}
        log("  Saved: "+masterOut+" [no dark subtraction]");
        continue;
      }

      log("  Using ["+sel.kind+"] optimize="+sel.optimize);

      var calOut = joinPath(outBase, (CFG.calibratedSubdirBase||"_CalibratedFlats")+"_"+kexp(exp)+"s");
      pulse("DARK_BEFORE_CALIBRATE");
      var calFiles = calibrateFlats(files, calOut, sel.path, sel.optimize, hintsCal) || [];
      pulse("DARK_AFTER_CALIBRATE");
      if(!calFiles.length){
        var ff=new FileFind;
        if(ff.begin(joinPath(calOut,"*.xisf"))){
          do{
            if(ff.isFile) calFiles.push(joinPath(calOut,ff.name));
          } while(ff.next());
        }
        ff.end();
      }
      if(!calFiles.length) throw new Error("No calibrated flats in "+calOut);

      pulse("DARK_BEFORE_INTEGRATE");
      integrateToMaster(calFiles, masterOut, false, hintsMaster, rej);
      pulse("DARK_AFTER_INTEGRATE");
      for (var pe2=0; pe2<10; pe2++)
        try{ if (typeof processEvents === "function") processEvents(); }catch(_){}
      log("  Saved: "+masterOut);

      if (CFG.deleteCalibrated){
        try{
          var delFF=new FileFind;
          if (delFF.begin(joinPath(calOut,"*"))){
            do{
              var p = joinPath(calOut, delFF.name);
              try { if (delFF.isFile) File.remove(p); } catch(e){}
            } while (delFF.next());
          }
          delFF.end();
          try { File.removeDirectory(calOut, true); } catch(e){}
          log("  [cleanup] removed "+calOut);
        } catch(e){
          warn("  [cleanup] failed "+calOut+" : "+e);
        }
      }
    }
  }

  log("\nAll processing complete.");
  pulse("DONE_OK");
  touch(__SENTINEL, "OK");
}

try{
  if (typeof CFG === "undefined") throw new Error("CFG not loaded - config file may have a syntax error");
  run();
} catch(e){
  error("ERROR: "+e);
  pulse("DONE_ERR:" + e);
  touch(__SENTINEL, "ERROR: "+e);
}
